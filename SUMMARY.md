# Lab 5 实验完成总结

## 📚 已完成的工作

### ✅ 练习1：加载应用程序并执行

**实现内容：**
- 完成了`load_icode`函数第6步的trapframe设置
- 实现了用户栈指针、程序入口点和状态寄存器的正确配置

**代码位置：**
`labcode/原始代码/lab5/kern/process/proc.c` 第753-761行

**核心代码：**
```c
tf->gpr.sp = USTACKTOP;                                // 用户栈顶
tf->epc = elf->e_entry;                                // ELF入口地址
tf->status = (sstatus & ~SSTATUS_SPP) | SSTATUS_SPIE;  // 用户态+中断使能
```

**详细说明：** 报告第二章，包含14步完整流程说明

---

### ✅ 练习2：父进程复制内存空间给子进程

**实现内容：**
- 完成了`copy_range`函数的页面复制逻辑
- 实现了物理页面内容的复制和映射建立

**代码位置：**
`labcode/原始代码/lab5/kern/mm/pmm.c` 第425-432行

**核心代码：**
```c
void *src_kvaddr = page2kva(page);              // 获取源页面地址
void *dst_kvaddr = page2kva(npage);             // 获取目标页面地址
memcpy(dst_kvaddr, src_kvaddr, PGSIZE);         // 复制页面内容
ret = page_insert(to, npage, start, perm);      // 建立映射关系
```

**详细说明：** 报告第三章，包含COW机制完整设计

---

### ✅ 练习3：理解fork/exec/wait/exit的实现

**分析内容：**
- fork系统调用的完整执行流程（用户态→内核态→用户态）
- exec系统调用的程序加载机制
- wait系统调用的子进程等待和资源回收
- exit系统调用的进程退出和资源释放

**详细说明：** 报告第四章，包含进程状态生命周期图

---

### ✅ 扩展问题：用户程序预加载机制

**分析内容：**
- 用户程序在编译时链接到内核的机制
- 与Linux等操作系统的区别对比
- ucore采用此方式的原因分析

**详细说明：** 报告第五章

---

## 📊 报告统计

| 项目 | 数量 |
|------|------|
| 总行数 | 1,612行 |
| 章节数 | 6个主要章节 |
| 代码示例 | 50+ 处 |
| 流程图/状态图 | 5个 |
| 核心函数分析 | 10+ 个 |

---

## 🎯 关键知识点

### 1. 进程执行流程（练习1）

```
系统初始化 → 创建进程 → 进程调度 → 上下文切换 
→ forkret → __trapret → sret → 执行用户程序第一条指令
```

### 2. 内存复制机制（练习2）

```
do_fork → copy_mm → dup_mmap → copy_range
                                    ↓
                          获取源页面 → 分配新页面 
                          → 复制内容 → 建立映射
```

### 3. 系统调用流程（练习3）

```
用户态：调用库函数 → 设置参数 → ecall指令
         ↓ (硬件自动切换到S-mode)
内核态：__alltraps → trap → syscall → 具体处理函数
         ↓ (通过sret返回)
用户态：从ecall下一条指令继续执行，a0寄存器包含返回值
```

### 4. 进程状态转换（练习3）

```
UNINIT → RUNNABLE ⟷ SLEEPING
              ↓
           ZOMBIE → (销毁)
```

---

## 💡 核心技术点

### trapframe的作用
保存进程在陷入内核时的CPU状态，包括：
- 所有通用寄存器（x0-x31）
- 程序计数器（epc）
- 状态寄存器（status）
- 用于内核态和用户态之间的切换

### context的作用
保存进程在内核态被调度时的CPU状态，包括：
- 返回地址（ra）
- 栈指针（sp）
- callee-saved寄存器（s0-s11）
- 用于进程间的切换

### COW机制优势
- 减少fork开销：不立即复制内存
- 节省内存：共享只读页面
- 适合fork-exec模式：避免无用复制

---

## 🔍 深入探讨的主题

1. **ELF文件格式**
   - 文件头结构
   - 程序段头（program header）
   - TEXT/DATA/BSS段的加载

2. **Copy-on-Write机制**
   - 状态转换设计
   - Page Fault处理
   - Dirty COW漏洞分析
   - 安全实现要点

3. **系统调用机制**
   - ecall指令的作用
   - 异常向量的设置
   - 参数传递（寄存器）
   - 返回值处理

4. **进程关系管理**
   - 父子进程链接（parent/cptr）
   - 兄弟进程链接（optr/yptr）
   - 进程树的维护
   - 孤儿进程的处理

---

## 📖 阅读路径建议

### 初级读者（理解基本概念）
1. 实验概述（第一章）
2. 练习1的实现代码（第二章2节）
3. 练习2的实现代码（第三章2节）
4. 用户程序预加载机制（第五章）

### 中级读者（理解执行流程）
1. 用户态进程执行流程（第二章4节）
2. fork/exec/wait/exit流程（第四章1-4节）
3. 用户态与内核态交互（第四章5节）
4. 进程状态生命周期（第四章6节）

### 高级读者（深入原理和设计）
1. trapframe和context的作用（第二章6节）
2. COW机制详细设计（第三章5节）
3. Dirty COW漏洞分析（第三章5.5节）
4. 与Linux的对比分析（第五章2节）

---

## 🎓 学习收获

通过本实验和报告，可以深入理解：

✅ **进程管理的核心机制**
- 进程的创建、调度、退出
- 进程间的关系管理
- 进程状态的转换

✅ **内存管理的实现**
- 页表的建立和映射
- 物理页面的分配和复制
- 虚拟内存的管理

✅ **特权级切换机制**
- 用户态和内核态的切换
- trapframe的保存和恢复
- 系统调用的实现

✅ **操作系统的设计思想**
- 模块化设计
- 资源管理和保护
- 性能优化（如COW）

---

## 📝 实验总结

本实验通过完成`load_icode`和`copy_range`两个关键函数，以及分析系统调用的实现，让我们深入理解了操作系统进程管理的核心机制。报告不仅包含了实现代码的详细讲解，还深入分析了执行流程、设计原理和优化技术。

特别是在COW机制的设计部分，报告提供了完整的实现代码和安全性分析，包括对著名的Dirty COW漏洞的剖析，这对于理解操作系统的安全性具有重要意义。

通过本实验的学习，为后续的文件系统、同步互斥等高级主题打下了坚实的基础。

---

**报告文件：** `lab5实验报告.md` (1,612行)
**概览文件：** `README_lab5.md`
**本总结：** `SUMMARY.md`
