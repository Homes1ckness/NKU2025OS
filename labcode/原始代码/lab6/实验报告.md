# Lab6 实验报告 - 调度器

## 练习1: 理解调度器框架的实现

### 1.1 调度类结构体 sched_class 的分析

`sched_class` 结构体定义在 `kern/schedule/sched.h` 中：

```c
struct sched_class {
    const char *name;                          // 调度器名称
    void (*init)(struct run_queue *rq);        // 初始化运行队列
    void (*enqueue)(struct run_queue *rq, struct proc_struct *proc);  // 入队
    void (*dequeue)(struct run_queue *rq, struct proc_struct *proc);  // 出队
    struct proc_struct *(*pick_next)(struct run_queue *rq);           // 选择下一个进程
    void (*proc_tick)(struct run_queue *rq, struct proc_struct *proc); // 时钟tick处理
};
```

**各函数指针的作用和调用时机：**

| 函数指针 | 作用 | 调用时机 |
|---------|------|---------|
| `init` | 初始化运行队列的数据结构 | 系统启动时`sched_init()`调用 |
| `enqueue` | 将进程加入就绪队列 | 进程创建后唤醒、时间片用完重新入队 |
| `dequeue` | 从就绪队列移除进程 | 进程被选中执行时 |
| `pick_next` | 选择下一个要执行的进程 | `schedule()`函数调度时 |
| `proc_tick` | 处理时钟中断，更新时间片 | 每次时钟中断时 |

**为什么使用函数指针而不是直接实现函数？**

1. **多态性**：允许不同调度算法（RR、Stride等）使用相同接口
2. **解耦合**：调度框架与具体算法分离，易于维护
3. **可扩展性**：添加新算法只需实现接口，无需修改框架代码
4. **运行时切换**：可以在运行时切换调度算法

### 1.2 运行队列结构体 run_queue 的分析

```c
struct run_queue {
    list_entry_t run_list;          // 链表头（RR算法使用）
    unsigned int proc_num;          // 就绪进程数量
    int max_time_slice;             // 最大时间片
    skew_heap_entry_t *lab6_run_pool; // 斜堆根节点（Stride算法使用）
};
```

**lab5与lab6的区别：**
- lab5：只有简单的链表结构
- lab6：增加了`lab6_run_pool`斜堆支持

**为什么需要两种数据结构？**

1. **RR算法**：使用链表，O(1)入队出队，FIFO顺序
2. **Stride算法**：使用斜堆（优先队列），O(log n)获取最小stride的进程

不同调度算法有不同的数据结构需求，框架需要同时支持。

### 1.3 调度器框架函数分析

**sched_init()函数：**
```c
void sched_init(void) {
    list_init(&timer_list);
    sched_class = &default_sched_class;  // 设置默认调度类
    rq = &__rq;
    rq->max_time_slice = MAX_TIME_SLICE;
    sched_class->init(rq);               // 调用具体算法的init
}
```

**wakeup_proc()函数：**
```c
void wakeup_proc(struct proc_struct *proc) {
    if (proc->state != PROC_RUNNABLE) {
        proc->state = PROC_RUNNABLE;
        proc->wait_state = 0;
        if (proc != current) {
            sched_class_enqueue(proc);  // 通过框架函数入队
        }
    }
}
```

**schedule()函数：**
```c
void schedule(void) {
    local_intr_save(intr_flag);
    current->need_resched = 0;
    if (current->state == PROC_RUNNABLE) {
        sched_class_enqueue(current);   // 当前进程重新入队
    }
    next = sched_class_pick_next();     // 选择下一个进程
    if (next != NULL) {
        sched_class_dequeue(next);      // 从队列移除
    }
    proc_run(next);                     // 切换到新进程
    local_intr_restore(intr_flag);
}
```

**解耦设计**：框架函数通过`sched_class`指针调用具体算法实现，无需知道具体算法细节。

### 1.4 调度类的初始化流程

```
kern_init()
    └─> sched_init()
            └─> sched_class = &default_sched_class
            └─> sched_class->init(rq)  // RR_init或stride_init
    └─> proc_init()
            └─> 创建idleproc和initproc
    └─> clock_init() + intr_enable()
            └─> 开始时钟中断，调度器开始工作
```

### 1.5 进程调度流程图

```
时钟中断触发
      │
      ▼
trap_dispatch()
      │
      ▼
IRQ_S_TIMER处理
      │
      ├─> clock_set_next_event()
      │
      ▼
sched_class_proc_tick(current)
      │
      ▼
RR_proc_tick() / stride_proc_tick()
      │
      ├─> time_slice--
      │
      ▼
time_slice == 0 ?
      │
      ├─ Yes ─> need_resched = 1
      │
      ▼
trap返回前检查need_resched
      │
      ├─ need_resched == 1
      │
      ▼
schedule()
      │
      ├─> enqueue(current)      // 当前进程入队
      │
      ├─> pick_next()           // 选择下一个进程
      │
      ├─> dequeue(next)         // 出队
      │
      ▼
proc_run(next)                  // 上下文切换
```

**need_resched标志位的作用**：
- 标记当前进程是否需要被调度
- 时间片用完时设置为1
- 在陷阱返回用户态前检查，决定是否调用schedule()

### 1.6 调度算法的切换机制

**添加新调度算法需要修改：**

1. 创建新文件（如`new_sched.c`），实现`sched_class`接口的5个函数
2. 在`sched_init()`中修改`sched_class`指针指向新的调度类

```c
// sched.c
void sched_init(void) {
    // sched_class = &default_sched_class;  // RR
    sched_class = &stride_sched_class;      // Stride
    // sched_class = &new_sched_class;      // 新算法
    ...
}
```

**为什么切换容易？**
- 统一的接口定义（`sched_class`结构体）
- 框架与算法解耦
- 只需修改一行指针赋值即可切换

---

## 练习2: 实现 Round Robin 调度算法

### 2.1 lab5与lab6函数差异分析

以`wakeup_proc()`为例：

**lab5版本：**
```c
void wakeup_proc(struct proc_struct *proc) {
    if (proc->state != PROC_RUNNABLE) {
        proc->state = PROC_RUNNABLE;
        proc->wait_state = 0;
    }
}
```

**lab6版本：**
```c
void wakeup_proc(struct proc_struct *proc) {
    if (proc->state != PROC_RUNNABLE) {
        proc->state = PROC_RUNNABLE;
        proc->wait_state = 0;
        if (proc != current) {
            sched_class_enqueue(proc);  // 新增：加入调度队列
        }
    }
}
```

**改动原因：**
- lab5没有调度框架，进程直接切换
- lab6需要通过调度队列管理就绪进程
- 不做改动会导致进程无法被调度器发现

### 2.2 RR算法实现

#### RR_init - 初始化运行队列
```c
static void RR_init(struct run_queue *rq) {
    list_init(&(rq->run_list));  // 初始化链表为空
    rq->proc_num = 0;            // 进程数为0
}
```

#### RR_enqueue - 进程入队
```c
static void RR_enqueue(struct run_queue *rq, struct proc_struct *proc) {
    assert(list_empty(&(proc->run_link)));  // 确保进程不在队列中
    list_add_before(&(rq->run_list), &(proc->run_link)); // 加入队尾(FIFO)
    if (proc->time_slice == 0 || proc->time_slice > rq->max_time_slice) {
        proc->time_slice = rq->max_time_slice;  // 重置时间片
    }
    proc->rq = rq;
    rq->proc_num++;
}
```

**选择`list_add_before`的原因**：
- `run_list`是哨兵节点，`list_add_before(&run_list, ...)`将元素加到链表尾部
- 实现FIFO顺序：新进程从尾部入队，老进程从头部出队

#### RR_dequeue - 进程出队
```c
static void RR_dequeue(struct run_queue *rq, struct proc_struct *proc) {
    assert(!list_empty(&(proc->run_link)) && proc->rq == rq);
    list_del_init(&(proc->run_link));  // 从链表删除并重新初始化
    rq->proc_num--;
}
```

#### RR_pick_next - 选择下一个进程
```c
static struct proc_struct *RR_pick_next(struct run_queue *rq) {
    list_entry_t *le = list_next(&(rq->run_list));
    if (le != &(rq->run_list)) {
        return le2proc(le, run_link);  // 返回队首进程
    }
    return NULL;
}
```

#### RR_proc_tick - 时钟tick处理
```c
static void RR_proc_tick(struct run_queue *rq, struct proc_struct *proc) {
    if (proc->time_slice > 0) {
        proc->time_slice--;  // 减少时间片
    }
    if (proc->time_slice == 0) {
        proc->need_resched = 1;  // 时间片用完，标记需要调度
    }
}
```

### 2.3 测试结果

```
make grade输出:
sched class: RR_scheduler
++ setup timer interrupts
kernel_execve: pid = 2, name = "priority".
set priority to 6
main: fork ok,now need to wait pids.
set priority to 1
set priority to 2
set priority to 3
set priority to 4
set priority to 5
```

所有进程都被正确调度执行。

### 2.4 RR算法优缺点分析

**优点：**
- 实现简单，易于理解
- 公平性好，每个进程获得相同时间片
- 响应时间可预测

**缺点：**
- 不区分进程优先级
- 时间片大小难以确定
  - 太小：上下文切换开销大
  - 太大：响应时间变长
- 不适合I/O密集型和CPU密集型混合场景

**need_resched标志的必要性：**
- 时钟中断处理在内核态，不能直接调用schedule()
- need_resched作为延迟标记，在安全点（陷阱返回前）才检查并调度

### 2.5 扩展思考

**优先级RR实现：**
- 维护多个队列，每个优先级一个
- pick_next时从最高优先级非空队列选择
- 或者修改enqueue按优先级排序插入

**多核调度支持：**
当前不支持多核，需要：
- 每个CPU核心一个运行队列
- 添加自旋锁保护共享数据
- 实现负载均衡机制

---

## 扩展练习 Challenge 1: Stride Scheduling

### 3.1 实现说明

Stride调度的核心思想：
- 每个进程有stride值，表示"虚拟运行时间"
- 选择stride最小的进程执行
- 执行后stride增加 `BIG_STRIDE / priority`
- 优先级高的进程stride增长慢，获得更多CPU时间

**BIG_STRIDE的选择：**
```c
#define BIG_STRIDE 0x7FFFFFFF  // 2^31 - 1
```

选择这个值是为了：
- 使用有符号32位比较，处理溢出
- 确保 `(stride1 - stride2)` 的差值在int32范围内

### 3.2 Stride算法实现

```c
static void stride_init(struct run_queue *rq) {
    list_init(&(rq->run_list));
    rq->lab6_run_pool = NULL;  // 斜堆初始化为空
    rq->proc_num = 0;
}

static void stride_enqueue(struct run_queue *rq, struct proc_struct *proc) {
#if USE_SKEW_HEAP
    rq->lab6_run_pool = skew_heap_insert(rq->lab6_run_pool,
                                          &(proc->lab6_run_pool),
                                          proc_stride_comp_f);
#else
    list_add_before(&(rq->run_list), &(proc->run_link));
#endif
    if (proc->time_slice == 0 || proc->time_slice > rq->max_time_slice) {
        proc->time_slice = rq->max_time_slice;
    }
    proc->rq = rq;
    rq->proc_num++;
}

static struct proc_struct *stride_pick_next(struct run_queue *rq) {
#if USE_SKEW_HEAP
    if (rq->lab6_run_pool == NULL) return NULL;
    struct proc_struct *p = le2proc(rq->lab6_run_pool, lab6_run_pool);
#else
    // 链表实现：遍历找最小stride
    ...
#endif
    // 更新stride
    if (p->lab6_priority == 0) {
        p->lab6_stride += BIG_STRIDE;
    } else {
        p->lab6_stride += BIG_STRIDE / p->lab6_priority;
    }
    return p;
}
```

### 3.3 Stride算法正确性说明

**为什么经过足够时间后，时间片分配与优先级成正比？**

设进程P1优先级为`p1`，P2优先级为`p2`。

stride增量：
- P1每次执行：`stride1 += BIG_STRIDE / p1`
- P2每次执行：`stride2 += BIG_STRIDE / p2`

经过N1次P1执行和N2次P2执行后，两者stride应大致相等：
```
N1 * (BIG_STRIDE / p1) ≈ N2 * (BIG_STRIDE / p2)
=> N1 / N2 ≈ p1 / p2
```

因此执行次数之比等于优先级之比，即CPU时间分配与优先级成正比。

### 3.4 多级反馈队列调度设计

**概要设计：**

1. **多级队列**：维护N个优先级队列Q0, Q1, ..., Q(N-1)
2. **时间片递增**：Qi的时间片为 `2^i * base_time_slice`
3. **优先级降级**：进程用完时间片后降到下一级队列
4. **优先级提升**：等待时间过长的进程提升优先级
5. **调度规则**：优先执行高优先级队列，同级内RR调度

**数据结构：**
```c
struct mlfq_run_queue {
    list_entry_t queues[NUM_QUEUES];  // 多个队列
    int time_slices[NUM_QUEUES];       // 各级时间片
    int proc_nums[NUM_QUEUES];
};
```

**关键函数：**
- `mlfq_enqueue`: 根据进程当前优先级入对应队列
- `mlfq_pick_next`: 从最高非空队列选择
- `mlfq_proc_tick`: 时间片用完降级

---

## 总结

本实验实现了：
1. **RR调度算法**：基于链表的时间片轮转
2. **Stride调度算法**：基于斜堆的按比例调度
3. **调度器框架**：通过函数指针实现多态

关键收获：
- 理解了调度器框架的解耦设计
- 掌握了不同调度算法的实现方法
- 学习了斜堆等高效数据结构的应用
