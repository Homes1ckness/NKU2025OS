# Lab2 分支任务实验报告：GDB调试页表查询过程

## 一、实验目的

1. 通过GDB调试QEMU源码，深入理解虚拟地址到物理地址的翻译过程
2. 观察QEMU模拟器中TLB查询和页表遍历的具体实现
3. 培养使用大模型辅助学习和调试的能力

## 二、实验环境配置

### 2.1 编译带调试信息的QEMU

首先需要重新编译QEMU以获取调试信息：

```bash
# 进入QEMU源码目录
cd ~/riscv/qemu-4.1.1

# 清理之前的编译结果
make distclean

# 重新配置，启用调试选项
./configure --target-list=riscv32-softmmu,riscv64-softmmu --enable-debug

# 重新编译
make -j$(nproc)
```

编译完成后，调试版QEMU位于：`~/riscv/qemu-4.1.1/riscv64-softmmu/qemu-system-riscv64`

### 2.2 修改Makefile

修改lab2的Makefile，使用调试版QEMU：

```makefile
QEMU := ~/riscv/qemu-4.1.1/riscv64-softmmu/qemu-system-riscv64
```

## 三、QEMU地址翻译源码分析

### 3.1 关键调用路径

通过分析QEMU源码，地址翻译的关键调用路径如下：

```
load_helper() / store_helper()     # accel/tcg/cputlb.c
    ↓
tlb_hit() / victim_tlb_hit()       # TLB查询
    ↓ (TLB Miss)
tlb_fill()                         # accel/tcg/cputlb.c:868
    ↓
riscv_cpu_tlb_fill()              # target/riscv/cpu_helper.c:435
    ↓
get_physical_address()            # target/riscv/cpu_helper.c:155
    ↓
tlb_set_page()                    # 将映射添加到TLB
```

### 3.2 关键源码文件

| 文件路径 | 功能描述 |
|---------|---------|
| `accel/tcg/cputlb.c` | TLB管理和内存访问的主要实现 |
| `target/riscv/cpu_helper.c` | RISC-V特定的地址翻译逻辑 |

### 3.3 TLB查询代码分析

#### 3.3.1 TLB命中检查

在 `accel/tcg/cputlb.c` 的 `load_helper()` 函数中（第1248-1280行）：

```c
static inline uint64_t __attribute__((always_inline))
load_helper(CPUArchState *env, target_ulong addr, TCGMemOpIdx oi,
            uintptr_t retaddr, size_t size, bool big_endian, bool code_read,
            FullLoadHelper *full_load)
{
    uintptr_t mmu_idx = get_mmuidx(oi);
    uintptr_t index = tlb_index(env, mmu_idx, addr);
    CPUTLBEntry *entry = tlb_entry(env, mmu_idx, addr);
    target_ulong tlb_addr = code_read ? entry->addr_code : entry->addr_read;

    // 关键分支：检查TLB是否命中
    if (!tlb_hit(tlb_addr, addr)) {
        // TLB未命中，先检查victim TLB
        if (!victim_tlb_hit(env, mmu_idx, index, tlb_off,
                            addr & TARGET_PAGE_MASK)) {
            // 都未命中，需要进行页表遍历
            tlb_fill(env_cpu(env), addr, size,
                     access_type, mmu_idx, retaddr);
        }
        // 重新获取TLB条目
        tlb_addr = code_read ? entry->addr_code : entry->addr_read;
    }
    // ...后续处理
}
```

**关键分支说明**：
1. `tlb_hit()` - 检查主TLB是否命中
2. `victim_tlb_hit()` - 检查victim TLB（二级TLB缓存）
3. 若都未命中，调用 `tlb_fill()` 进行页表遍历

#### 3.3.2 Victim TLB机制

在 `cputlb.c` 第977-1011行：

```c
static bool victim_tlb_hit(CPUArchState *env, size_t mmu_idx, size_t index,
                           size_t elt_ofs, target_ulong page)
{
    size_t vidx;

    for (vidx = 0; vidx < CPU_VTLB_SIZE; ++vidx) {
        CPUTLBEntry *vtlb = &env_tlb(env)->d[mmu_idx].vtable[vidx];
        target_ulong cmp;

        cmp = atomic_read((target_ulong *)((uintptr_t)vtlb + elt_ofs));

        if (cmp == page) {
            // 在victim TLB中找到，交换到主TLB
            CPUTLBEntry tmptlb, *tlb = &env_tlb(env)->f[mmu_idx].table[index];

            qemu_spin_lock(&env_tlb(env)->c.lock);
            copy_tlb_helper_locked(&tmptlb, tlb);
            copy_tlb_helper_locked(tlb, vtlb);
            copy_tlb_helper_locked(vtlb, &tmptlb);
            qemu_spin_unlock(&env_tlb(env)->c.lock);

            // 同时交换IOTLB条目
            CPUIOTLBEntry tmpio, *io = &env_tlb(env)->d[mmu_idx].iotlb[index];
            CPUIOTLBEntry *vio = &env_tlb(env)->d[mmu_idx].viotlb[vidx];
            tmpio = *io; *io = *vio; *vio = tmpio;
            return true;
        }
    }
    return false;
}
```

### 3.4 页表遍历代码分析

在 `target/riscv/cpu_helper.c` 的 `get_physical_address()` 函数中（第155-353行）：

#### 3.4.1 分页模式判断

```c
static int get_physical_address(CPURISCVState *env, hwaddr *physical,
                                int *prot, target_ulong addr,
                                int access_type, int mmu_idx)
{
    int mode = mmu_idx;

    // 关键分支1：M模式下的MPRV位检查
    if (mode == PRV_M && access_type != MMU_INST_FETCH) {
        if (get_field(env->mstatus, MSTATUS_MPRV)) {
            mode = get_field(env->mstatus, MSTATUS_MPP);
        }
    }

    // 关键分支2：M模式或无MMU时直接返回物理地址
    if (mode == PRV_M || !riscv_feature(env, RISCV_FEATURE_MMU)) {
        *physical = addr;
        *prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;
        return TRANSLATE_SUCCESS;
    }
```

#### 3.4.2 SV39页表参数配置

```c
    // 从SATP寄存器获取页表基址
    base = get_field(env->satp, SATP_PPN) << PGSHIFT;
    vm = get_field(env->satp, SATP_MODE);

    // 关键分支3：根据分页模式设置参数
    switch (vm) {
    case VM_1_10_SV32:
        levels = 2; ptidxbits = 10; ptesize = 4; break;
    case VM_1_10_SV39:
        levels = 3; ptidxbits = 9; ptesize = 8; break;  // ucore使用此模式
    case VM_1_10_SV48:
        levels = 4; ptidxbits = 9; ptesize = 8; break;
    case VM_1_10_MBARE:
        // 无分页，直接返回
        *physical = addr;
        *prot = PAGE_READ | PAGE_WRITE | PAGE_EXEC;
        return TRANSLATE_SUCCESS;
    }
```

#### 3.4.3 三级页表遍历（核心循环）

```c
    int ptshift = (levels - 1) * ptidxbits;  // SV39: ptshift = 18

    for (i = 0; i < levels; i++, ptshift -= ptidxbits) {
        // 计算当前级页表索引
        target_ulong idx = (addr >> (PGSHIFT + ptshift)) &
                           ((1 << ptidxbits) - 1);

        // 计算页表项地址
        target_ulong pte_addr = base + idx * ptesize;

        // PMP权限检查
        if (riscv_feature(env, RISCV_FEATURE_PMP) &&
            !pmp_hart_has_privs(env, pte_addr, sizeof(target_ulong),
            1 << MMU_DATA_LOAD, PRV_S)) {
            return TRANSLATE_PMP_FAIL;
        }

        // 读取页表项（关键操作）
        target_ulong pte = ldq_phys(cs->as, pte_addr);
        target_ulong ppn = pte >> PTE_PPN_SHIFT;

        // 关键分支4：PTE有效位检查
        if (!(pte & PTE_V)) {
            return TRANSLATE_FAIL;  // 无效PTE
        }
        // 关键分支5：判断是叶子节点还是目录项
        else if (!(pte & (PTE_R | PTE_W | PTE_X))) {
            // 目录项，继续遍历下一级
            base = ppn << PGSHIFT;
        }
        // 关键分支6：各种权限检查
        else if ((pte & (PTE_R | PTE_W | PTE_X)) == PTE_W) {
            return TRANSLATE_FAIL;  // 保留的PTE标志
        } else if ((pte & (PTE_R | PTE_W | PTE_X)) == (PTE_W | PTE_X)) {
            return TRANSLATE_FAIL;  // 保留的PTE标志
        } else if ((pte & PTE_U) && ((mode != PRV_U) &&
                   (!sum || access_type == MMU_INST_FETCH))) {
            return TRANSLATE_FAIL;  // 用户页在非用户模式访问
        } else if (!(pte & PTE_U) && (mode != PRV_S)) {
            return TRANSLATE_FAIL;  // 内核页在非内核模式访问
        } else if (access_type == MMU_DATA_LOAD && !((pte & PTE_R) ||
                   ((pte & PTE_X) && mxr))) {
            return TRANSLATE_FAIL;  // 读权限检查失败
        } else if (access_type == MMU_DATA_STORE && !(pte & PTE_W)) {
            return TRANSLATE_FAIL;  // 写权限检查失败
        } else if (access_type == MMU_INST_FETCH && !(pte & PTE_X)) {
            return TRANSLATE_FAIL;  // 执行权限检查失败
        } else {
            // 成功找到叶子PTE，计算物理地址
            target_ulong vpn = addr >> PGSHIFT;
            *physical = (ppn | (vpn & ((1L << ptshift) - 1))) << PGSHIFT;

            // 设置权限位
            if ((pte & PTE_R) || ((pte & PTE_X) && mxr)) {
                *prot |= PAGE_READ;
            }
            if ((pte & PTE_X)) {
                *prot |= PAGE_EXEC;
            }
            if ((pte & PTE_W) &&
                    (access_type == MMU_DATA_STORE || (pte & PTE_D))) {
                *prot |= PAGE_WRITE;
            }
            return TRANSLATE_SUCCESS;
        }
    }
    return TRANSLATE_FAIL;
}
```

### 3.5 地址翻译流程图

```
┌─────────────────────────────────────────────────────────────────┐
│                        访存指令执行                               │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
                    ┌─────────────────┐
                    │  查询主TLB      │
                    │  tlb_hit()      │
                    └─────────────────┘
                              │
              ┌───────────────┴───────────────┐
              │                               │
         命中 ▼                          未命中 ▼
    ┌─────────────┐                 ┌─────────────────┐
    │ 直接使用    │                 │ 查询Victim TLB  │
    │ 物理地址    │                 │ victim_tlb_hit()│
    └─────────────┘                 └─────────────────┘
                                              │
                              ┌───────────────┴───────────────┐
                              │                               │
                         命中 ▼                          未命中 ▼
                    ┌─────────────┐              ┌─────────────────┐
                    │ 交换到主TLB │              │ 页表遍历        │
                    │ 使用物理地址│              │ get_physical_   │
                    └─────────────┘              │ address()       │
                                                 └─────────────────┘
                                                          │
                                                          ▼
                                                 ┌─────────────────┐
                                                 │ 三级页表遍历    │
                                                 │ (SV39模式)      │
                                                 └─────────────────┘
                                                          │
                                                          ▼
                                                 ┌─────────────────┐
                                                 │ 添加到TLB       │
                                                 │ tlb_set_page()  │
                                                 └─────────────────┘
```

## 四、调试步骤详解

### 4.1 启动调试环境（三终端法）

**终端1：启动QEMU**
```bash
cd /path/to/lab2
make debug
```

**终端2：附加到QEMU进程**
```bash
# 查找QEMU进程PID
pgrep -f qemu-system-riscv64

# 启动GDB并附加
sudo gdb
(gdb) attach <PID>
(gdb) handle SIGPIPE nostop noprint
(gdb) file ~/riscv/qemu-4.1.1/riscv64-softmmu/qemu-system-riscv64

# 设置断点
(gdb) b get_physical_address
(gdb) b riscv_cpu_tlb_fill
(gdb) continue
```

**终端3：调试ucore内核**
```bash
cd /path/to/lab2
make gdb
(gdb) b kern_init
(gdb) continue
```

### 4.2 条件断点设置

为了观察特定地址的翻译过程，可以设置条件断点：

```gdb
# 在get_physical_address处设置条件断点
# 例如，监控kern_init入口地址0x80200000的翻译
(gdb) b get_physical_address if addr == 0x80200000

# 或监控特定虚拟地址范围
(gdb) b get_physical_address if addr >= 0x80200000 && addr < 0x80210000
```

### 4.3 关键调试命令

```gdb
# 查看当前虚拟地址
(gdb) p/x addr

# 查看SATP寄存器值
(gdb) p/x env->satp

# 查看页表基址
(gdb) p/x (env->satp & 0xFFFFFFFFFFF) << 12

# 查看页表项
(gdb) p/x pte

# 查看翻译结果
(gdb) p/x *physical

# 单步执行页表遍历循环
(gdb) n
```

## 五、QEMU TLB与真实CPU TLB的区别

### 5.1 结构差异

| 特性 | QEMU软件TLB | 真实CPU TLB |
|------|------------|-------------|
| 实现方式 | 软件数据结构（哈希表） | 硬件CAM（内容寻址存储器） |
| 查找方式 | 索引计算 + 比较 | 并行匹配 |
| 容量 | 可动态调整 | 固定大小 |
| 访问延迟 | 数百CPU周期 | 1-2 CPU周期 |
| Victim TLB | 软件维护的数组 | 硬件实现（部分CPU有） |

### 5.2 功能差异

**QEMU TLB的特点**：
1. **软件模拟**：完全用C代码实现，便于调试和观察
2. **无ASID支持**：简化的实现，每次上下文切换需要刷新TLB
3. **统一处理**：不区分ITLB和DTLB
4. **动态大小**：根据使用率自动调整TLB大小

**真实CPU TLB的特点**：
1. **硬件实现**：全相联或组相联结构
2. **ASID支持**：避免上下文切换时刷新TLB
3. **分离设计**：独立的ITLB和DTLB
4. **固定容量**：设计时确定

### 5.3 开启/关闭虚拟地址空间对比

通过调试可以观察到：

**未开启虚拟地址空间（MBARE模式）**：
```
get_physical_address()
  → 检测到 VM_1_10_MBARE
  → 直接返回 *physical = addr
  → 不进行页表遍历
```

**开启虚拟地址空间（SV39模式）**：
```
get_physical_address()
  → 检测到 VM_1_10_SV39
  → 从SATP获取页表基址
  → 三级页表遍历
  → 返回翻译后的物理地址
```

## 六、调试过程中的有趣发现

### 6.1 TLB动态调整机制

QEMU实现了智能的TLB大小调整策略（`tlb_mmu_resize_locked()`）：

- 使用率 > 70%：TLB大小翻倍
- 使用率 < 30% 且时间窗口过期：缩小TLB
- 目标使用率：30%-70%

这是一种权衡策略，太大的TLB虽然命中率高，但刷新开销大。

### 6.2 原子操作保护

在多线程TCG（MTTCG）环境下，页表更新使用原子操作：

```c
target_ulong old_pte = atomic_cmpxchg(pte_pa, pte, updated_pte);
if (old_pte != pte) {
    goto restart;  // PTE被修改，重新遍历
}
```

### 6.3 大页支持的简化处理

QEMU的TLB不直接支持大页，而是记录大页区域，在刷新时整体处理：

```c
static void tlb_add_large_page(CPUArchState *env, int mmu_idx,
                               target_ulong vaddr, target_ulong size)
{
    // 记录大页地址和掩码，便于后续刷新
    env_tlb(env)->d[mmu_idx].large_page_addr = lp_addr & lp_mask;
    env_tlb(env)->d[mmu_idx].large_page_mask = lp_mask;
}
```

## 七、大模型辅助调试记录

### 7.1 问题1：如何找到地址翻译相关代码

**提问**：我需要调试QEMU中RISC-V的地址翻译代码，应该关注哪些源文件？

**大模型回答要点**：
- `target/riscv/cpu_helper.c` - RISC-V特定的MMU实现
- `accel/tcg/cputlb.c` - 通用TLB管理
- 关键函数：`get_physical_address()`、`riscv_cpu_tlb_fill()`

### 7.2 问题2：SIGPIPE信号处理

**场景**：GDB附加到QEMU后频繁收到SIGPIPE信号

**提问**：为什么会收到SIGPIPE，如何处理？

**大模型解释**：
- QEMU使用管道进行进程间通信
- 当管道的读端关闭而写端继续写入时产生SIGPIPE
- 解决方案：`handle SIGPIPE nostop noprint`

### 7.3 问题3：条件断点语法

**提问**：如何设置只在特定地址翻译时触发的断点？

**大模型回答**：
```gdb
# 基本条件断点
b get_physical_address if addr == 0x80200000

# 范围条件
b get_physical_address if addr >= 0x80200000 && addr < 0x80300000

# 组合条件
b get_physical_address if addr == 0x80200000 && access_type == 2
```

## 八、实验总结

### 8.1 主要收获

1. **深入理解地址翻译**：通过源码级调试，清晰地看到了虚拟地址如何通过多级页表翻译为物理地址
2. **理解软件模拟硬件**：QEMU用软件完整模拟了硬件MMU的行为，便于学习和调试
3. **掌握双重调试技术**：同时调试模拟器和被模拟系统的技术非常有价值
4. **大模型辅助学习**：学会利用大模型快速定位问题和获取技术细节

### 8.2 关键代码位置总结

| 功能 | 文件 | 行号/函数 |
|------|------|----------|
| TLB命中检查 | cputlb.c | `tlb_hit()`, 第1271行 |
| Victim TLB | cputlb.c | `victim_tlb_hit()`, 第977-1011行 |
| TLB填充 | cputlb.c | `tlb_fill()`, 第868-880行 |
| 页表遍历 | cpu_helper.c | `get_physical_address()`, 第155-353行 |
| TLB设置 | cputlb.c | `tlb_set_page()`, 第843-849行 |

### 8.3 建议的进一步探索

1. 研究QEMU的TCG（Tiny Code Generator）如何生成访存代码
2. 对比不同RISC-V扩展（如Svnapot大页扩展）的实现
3. 分析QEMU多核环境下的TLB一致性维护
